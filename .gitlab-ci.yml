# If SonarQube results are a gate to image building, keep your stages ordering.
# If security scanning is a higher priority, consider scanning the image right after building then put the sonarqube check after image scanning.
stages:
  - trivy-dependency-check
  # - owasp-dependency-check
  - sonarqube-check
  - build-container-image
  - trivy-container-scan
  - push-container-image
  # - deploy-to-k8s

trivy-dependency-check:
  stage: trivy-dependency-check
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  script:
    - trivy config . # Scans your project configuration files (like terraform, dockerfile, k8s manifests) (optional but useful).
    - trivy fs --exit-code 1 --severity HIGH,CRITICAL --ignore-unfixed .
  allow_failure: true
  interruptible: true
  only:
    - merge_requests
    - main
    - dev

############################################ No need for owasp as we already have the trivy dependencies check ############################################ 
# owasp_dependency_check:
#   image:
#     name: registry.gitlab.com/gitlab-ci-utils/docker-dependency-check:latest
#     entrypoint: [""]
#   stage: dependency_check
#   script:
#     - /usr/share/dependency-check/bin/dependency-check.sh --scan "./" --format ALL --project "$CI_PROJECT_NAME" --enableExperimental
#   allow_failure: true
#   interruptible: true
#   artifacts:
#     when: always
#     paths:
#       - "./dependency-check-report.html"
#   only:
#     - merge_requests
#     - main
#     - dev

sonarqube-check:
  stage: sonarqube-check
  image: 
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
    GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script: 
    - sonar-scanner -Dsonar.projectKey=microservices -Dsonar.host.url=$SONAR_HOST_URL -Dsonar.login=$SONAR_TOKEN -Dsonar.qualitygate.wait=false -Dsonar.dependencyCheck.htmlReportPath=./dependency-check-report.html -Dsonar.exclusions=**/dependency-check-report.html
  allow_failure: true
  interruptible: true
  only:
    - merge_requests
    - main
    - dev

build-container-image:
  stage: build-container-image
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_DRIVER: overlay2
    IMAGE_NAME: mohamedsamirebrahim/microservices-python-image
    DOCKER_TLS_CERTDIR: ""
    IMAGE_TAG: "${CI_COMMIT_REF_NAME}-${CI_PIPELINE_IID}"
  before_script:
    - echo "$DOCKERHUB_PASSWORD" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
  script:
    - docker build --no-cache -t $IMAGE_NAME:$IMAGE_TAG -t $IMAGE_NAME:latest .
    - docker save $IMAGE_NAME:$IMAGE_TAG -o image.tar  # Save image for scan
  artifacts:
    paths:
      - image.tar
  interruptible: true
  only:
    - merge_requests
    - main
    - dev

trivy-container-scan:
  stage: trivy-container-scan
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  script:
    - trivy image --input image.tar --exit-code 1 --severity HIGH,CRITICAL --ignore-unfixed
  dependencies:
    - build-container-image
  allow_failure: true
  interruptible: true
  only:
    - merge_requests
    - main
    - dev

push-container-image:
  stage: push-container-image
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_DRIVER: overlay2
    IMAGE_NAME: mohamedsamirebrahim/microservices-python-image
    DOCKER_TLS_CERTDIR: ""
    IMAGE_TAG: "${CI_COMMIT_REF_NAME}-${CI_PIPELINE_IID}"
  before_script:
    - echo "$DOCKERHUB_PASSWORD" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
  script:
    - docker load -i image.tar  # Load previously saved image
    - docker push $IMAGE_NAME:$IMAGE_TAG
  dependencies:
    - build-container-image
  interruptible: true
  rules:
    # Your rules do allow the job to run in merge requests, but only if the source branch is dev or main
    # If on prod branch, require manual action
    - if: '$CI_COMMIT_REF_NAME == "main"'
      when: manual
    # If on dev branch, run automatically as soon as dependencies succeed
    - if: '$CI_COMMIT_REF_NAME == "dev"'
      when: on_success
    # Fallback: don't run on any other branch
    - when: never




# deploy-to-k8s:
#   stage: deploy-to-k8s
#   image:
#     name: bitnami/kubectl:latest
#     entrypoint: ['']
#   before_script:
#     - KUBECONFIG=~/.kube/config
#     - IMAGE_NAME=mohamedsamirebrahim/microservices-python-image
#     - echo $kube_config | base64 -d > $KUBECONFIG
#     - kubectl config use-context arn:aws:eks:us-east-1:948763340657:cluster/my-eks-cluster-gitlab-rollout-manager
#   script:
#     - kubectl config get-contexts
#     - kubectl set image deployment/microservices-app -n default microservices-container=$IMAGE_NAME:$CI_PIPELINE_IID
#     - kubectl rollout status deployment/microservices-app -n default
#   when: manual
#   interruptible: true
#   only:
#      - main