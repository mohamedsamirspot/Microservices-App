name: ci


# If SonarQube results are a gate to image building, keep your stages ordering.
# If security scanning is a higher priority, consider scanning the image right after building then put the sonarqube check after image scanning.


# ✔ Push events = accepted code → OK to build & publish images
# ❌ PR events = proposed code → run checks only, no publishing
# | Event                                                               | Triggers **Release-Tag Workflow**  | Triggers **CI Workflow** | Notes                                                  |
# | ------------------------------------------------------------------- | ---------------------------------  | ------------------------ | ------------------------------------------------------ |
# | **Push to `dev, test` branch**                                      | ❌ No                              | ✅ Yes                    | Builds & scans **dev images** → `dev-123`              |
# | **Push to `main` branch**                                           | ✅ Yes                             | ❌ No                     | Release workflow bumps version & creates tag           |
# | **Pull request into `dev, test`**                                   | ❌ No                              | ⚠️ Yes (CI only)         | Runs tests/scans; **no images pushed**                 |
# | **Pull request into `main`**                                        | ❌ No                              | ⚠️ Yes (CI only)         | Allows validation before merging; **no images pushed** |
# | **Merge into `main`**                                               | ✅ Yes                             | ❌ No                     | Release workflow creates Git tag (`vX.Y.Z`)            |
# | **Git tag pushed (vX.Y.Z)**                                         | ❌ No                              | ✅ Yes                    | Builds **production image** → `vX.Y.Z`, `latest`       |
# | **Manual run (workflow_dispatch)**                                  | ❌ No                              | ✅ Yes                    | Manually run full CI pipeline                          |
# | **Push to any other branch (feature/* etc.)**                       | ❌ No                              | ❌ No                     | CI is not triggered unless configured                  |
# | **Automatic tag created by release workflow "only in main branch"** | (This workflow creates it)          | ✅ Yes                    | CI runs on tags created by release workflow            |


on:
  repository_dispatch:
    types: [ release-created ]
  workflow_dispatch:
  push:
    branches: [ dev, test ]
  pull_request:
    branches: [ main, dev, test ]

concurrency:
  group: ci-group
  # the default is wait
  cancel-in-progress: false

env:
  IMAGE_NAME: mohamedsamirebrahim/microservices-python-image

jobs:
  #SCA: Strengthen with Snyk or pip-audit if you can: Trivy FS is good but adding a Python-specific tool catches more
  trivy-dependency-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      # Scans your project configuration files (like terraform, dockerfile, k8s manifests) (optional but useful).
      - name: Run Trivy Config Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: config
          severity: HIGH,CRITICAL
          ignore-unfixed: true
      - name: Run Trivy FS Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: fs
          severity: HIGH,CRITICAL
          ignore-unfixed: true

  #SAST: Add Bandit (Python-specific) if you can: SonarQube is broad; Bandit is purpose-built for Python security issues (SQL injection, hardcoded secrets, unsafe deserialization, etc.):
  sonarqube-check:
    runs-on: ubuntu-latest
    needs: trivy-dependency-check
    continue-on-error: true
    steps:
      - uses: actions/checkout@v6
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v7
        with:
          args: >
            -Dsonar.projectKey=microservices
            -Dsonar.host.url=${{ vars.SONAR_HOST_URL }}
            -Dsonar.login=${{ secrets.SONAR_TOKEN }}
            -Dsonar.qualitygate.wait=false
            -Dsonar.exclusions=**/dependency-check-report.html

  #SCA
  build-and-trivy-scan-container-image:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    needs: sonarqube-check
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Determine Docker image tag
        id: version
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            # Release triggered by release-tag workflow → semantic tag
            echo "TAG=${{ github.event.client_payload.tag }}" >> $GITHUB_OUTPUT
          else
            # All other branches → dynamic branch-based tag
            BRANCH_NAME=${GITHUB_REF##*/}
            echo "TAG=${BRANCH_NAME}-${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
          fi
      - name: Build Docker image
        run: |
          docker build -t $IMAGE_NAME:${{ steps.version.outputs.TAG }} .
      - name: Scan Image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ steps.version.outputs.TAG }}
          scan-type: image
          severity: HIGH,CRITICAL
          ignore-unfixed: true
      - name: Save image
        run: docker save $IMAGE_NAME:${{ steps.version.outputs.TAG }} -o image.tar
      - name: Upload TAR artifact
        uses: actions/upload-artifact@v7
        with:
          name: docker-image
          path: image.tar

  #DAST
  dast-zap:
      runs-on: ubuntu-latest
      needs: build-and-trivy-scan-container-image
      if: github.event_name != 'pull_request'
      steps:
        - name: Checkout
          uses: actions/checkout@v6
        - name: Download image TAR
          uses: actions/download-artifact@v7
          with:
            name: docker-image
        - name: Load image
          run: docker load -i image.tar
        - name: Determine Docker image tag
          id: version
          run: |
            if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
              echo "TAG=${{ github.event.client_payload.tag }}" >> $GITHUB_OUTPUT
            else
              BRANCH_NAME=${GITHUB_REF##*/}
              echo "TAG=${BRANCH_NAME}-${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
            fi
        - name: Run Flask app
          run: |
            docker run -d --name flask-app -p 5000:5000 \
              ${{ env.IMAGE_NAME }}:${{ steps.version.outputs.TAG }}
            sleep 10
        - name: Wait for Flask app to be ready
          run: |
            for i in {1..10}; do
              if curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/products | grep -q "200"; then
                echo "App is ready"
                break
              fi
              echo "Waiting... attempt $i"
              sleep 3
            done
        - name: Fix workspace permissions for ZAP
          run: chmod a+w ${{ github.workspace }}
        - name: Run ZAP Scan on /products
          uses: zaproxy/action-baseline@v0.12.0
          with:
            target: 'http://localhost:5000/products'
            fail_action: false
            artifact_name: zapreportproducts # set true to break pipeline on findings
            allow_issue_writing: false # disables auto issue creation
        - name: Fix workspace permissions for ZAP (second scan)
          run: chmod a+w ${{ github.workspace }}
        - name: Run ZAP Scan on /users
          uses: zaproxy/action-baseline@v0.12.0
          with:
            target: 'http://localhost:5000/users'
            fail_action: false
            artifact_name: zapreportusers # set true to break pipeline on findings
            allow_issue_writing: false # disables auto issue creation
        - name: Stop Flask app
          if: always()
          run: docker stop flask-app && docker rm flask-app

  push-container-image:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    needs: dast-zap
    steps:
      - name: Download image TAR
        uses: actions/download-artifact@v8
        with:
          name: docker-image
      - name: Load image
        run: docker load -i image.tar
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}
      - name: Determine Docker image tag
        id: version
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            # Release triggered by release-tag workflow → semantic tag
            echo "TAG=${{ github.event.client_payload.tag }}" >> $GITHUB_OUTPUT
          else
            # All other branches → dynamic branch-based tag
            BRANCH_NAME=${GITHUB_REF##*/}
            echo "TAG=${BRANCH_NAME}-${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
          fi
      - name: Push image
        run: |
          docker push $IMAGE_NAME:${{ steps.version.outputs.TAG }}

#------------------ Multi-Arch Docker Buildx Reference ------------------#
# Docker does not support saving a multi-arch image as a single TAR and re-loading it later so you have to build again in the push step.
  ##SCA
  # build-and-trivy-scan-container-images:
  #   if: github.event_name != 'pull_request'
  #   runs-on: ubuntu-latest
  #   needs: sonarqube-check
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v6

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     - name: Determine Docker image tag
  #       id: version
  #       run: |
  #         if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
  #           echo "TAG=${{ github.event.client_payload.tag }}" >> $GITHUB_OUTPUT
  #         else
  #           BRANCH_NAME=${GITHUB_REF##*/}
  #           echo "TAG=${BRANCH_NAME}-${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
  #         fi
  #     # ---------------- amd64 ----------------
  #     - name: Build amd64 image (OCI)
  #       run: |
  #         docker buildx build \
  #           --platform linux/amd64 \
  #           -t $IMAGE_NAME:${{ steps.version.outputs.TAG }}-amd64 \
  #           --cache-from type=gha \
  #           --cache-to type=gha,mode=max \
  #           --output type=oci,dest=image-amd64.tar \
  #           .
  #     - name: Extract amd64 image
  #       run: |
  #         mkdir image-amd64
  #         tar -xf image-amd64.tar -C image-amd64
  #     - name: Show amd64 platform metadata
  #       run: |
  #         jq '.manifests[0].platform' image-amd64/index.json
  #     - name: Scan amd64 image with Trivy
  #       uses: aquasecurity/trivy-action@master
  #       with:
  #         scan-type: image
  #         input: image-amd64
  #         severity: HIGH,CRITICAL
  #         ignore-unfixed: true
  #     # ---------------- arm64 ----------------
  #     - name: Build arm64 image (OCI)
  #       run: |
  #         docker buildx build \
  #           --platform linux/arm64 \
  #           -t $IMAGE_NAME:${{ steps.version.outputs.TAG }}-arm64 \
  #           --cache-from type=gha \
  #           --cache-to type=gha,mode=max \
  #           --output type=oci,dest=image-arm64.tar \
  #           .
  #     - name: Extract arm64 image
  #       run: |
  #         mkdir image-arm64
  #         tar -xf image-arm64.tar -C image-arm64
  #     - name: Show arm64 platform metadata
  #       run: |
  #         jq '.manifests[0].platform' image-arm64/index.json
  #     - name: Scan arm64 image with Trivy
  #       uses: aquasecurity/trivy-action@master
  #       with:
  #         scan-type: image
  #         input: image-arm64
  #         severity: HIGH,CRITICAL
  #         ignore-unfixed: true


  # push-container-image:
  #   if: github.event_name != 'pull_request'
  #   runs-on: ubuntu-latest
  #   needs: dast-zap
  #   steps:
  #     - uses: actions/checkout@v6

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     - name: Login to DockerHub
  #       uses: docker/login-action@v3
  #       with:
  #         username: ${{ vars.DOCKERHUB_USERNAME }}
  #         password: ${{ secrets.DOCKERHUB_PASSWORD }}

  #     - name: Determine Docker image tag
  #       id: version
  #       run: |
  #         if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
  #           echo "TAG=${{ github.event.client_payload.tag }}" >> $GITHUB_OUTPUT
  #         else
  #           BRANCH_NAME=${GITHUB_REF##*/}
  #           echo "TAG=${BRANCH_NAME}-${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
  #         fi

  #     - name: Build & push multi-arch image
  #       run: |
  #         docker buildx build \
  #           --platform linux/amd64,linux/arm64 \
  #           -t $IMAGE_NAME:${{ steps.version.outputs.TAG }} \
  #           --cache-from type=gha \
  #           --cache-to type=gha,mode=max \
  #           --push \
  #           .
